{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"dependence","text":"<p>Dependence provides a Command Line Interface and library for performing dependency upgrades on a python project, aligning declared dependencies with the package versions installed in the environment in which <code>dependence</code> is executed, and for \"freezing\" recursively resolved package dependencies (like <code>pip freeze</code>, but for a package, instead of the entire environment).</p>"},{"location":"#installation","title":"Installation","text":"<p>You can install <code>dependence</code> with pip:</p> <pre><code>pip3 install dependence\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#upgrading-dependencies","title":"Upgrading Dependencies","text":"<p>The <code>dependence upgrade</code> command, and the <code>dependence.upgrade.upgrade</code> function, discover and upgrade project and environment dependencies in the environment in which dependence is installed to their latest version aligned with project and dependency requirements, then selectively update requirement specifiers in any specified TOML files (such as pyproject.toml), setup.cfg file, requirements.txt files, or tox.ini files. Because pyproject.toml files may contain dependencies for more than one environment, such as when using hatch environments, JSON-style pointers are used to include or exclude specific parts of TOML files.</p> <p>For example, in this project's Makefile , we define a <code>make upgrade</code> target as follows:</p> <pre><code>SHELL := bash\nPYTHON_VERSION := 3.10\n\nupgrade:\n    hatch run dependence upgrade\\\n     --include-pointer /tool/hatch/envs/default\\\n     --include-pointer /project\\\n     pyproject.toml &amp;&amp; \\\n    hatch run docs:dependence upgrade\\\n     --include-pointer /tool/hatch/envs/docs\\\n     --include-pointer /project\\\n     pyproject.toml &amp;&amp; \\\n    hatch run hatch-static-analysis:dependence upgrade\\\n     --include-pointer /tool/hatch/envs/docs\\\n     --include-pointer /project\\\n     pyproject.toml &amp;&amp; \\\n    hatch run hatch-test.py$(PYTHON_VERSION):dependence upgrade\\\n     --include-pointer /tool/hatch/envs/hatch-test\\\n     --include-pointer /project\\\n     pyproject.toml &amp;&amp; \\\n    make requirements\n</code></pre> <p>You can reference the associated pyproject.toml file for this project  for reference concerning the implications of <code>--include-pointer</code>, which uses identical syntax to JSON pointers . The <code>--exclude-pointer</code> parameter works identically, but in reverse. If both <code>--include-pointer</code> and <code>--exclude-pointer</code> are used, only sections which match both conditions will be updated.</p> <p>You may refer to the <code>dependence upgrade</code> CLI reference and/or <code>dependence.upgrade</code> API reference for details concerning this command/module, related options, and more complex use case examples.</p> <p>The <code>dependence upgrade</code> command, and the <code>dependence.upgrade.upgrade</code> function, are simply a composite of the dependency listing and update functionalities covered below, but which a <code>pip install --upgrade</code> command executed in between\u2014so please read further for additional details. All parameters are directly passed, with the exception of <code>--ignore-update</code>/<code>ignore_update</code>, which is translated to the <code>--ignore</code>/<code>ignore</code> parameter for <code>dependence update</code>/<code>dependence.update.update</code> (renamed in this operation for clarity of purpose).</p>"},{"location":"#listing-dependencies","title":"Listing Dependencies","text":"<p>The <code>dependence freeze</code> command, and the <code>dependence.freeze.freeze</code> function, print all requirements for one or more specified python project, requirements.txt, pyproject.toml, setup.cfg, or tox.ini files. The output format matches that of <code>pip freeze</code>, but only lists dependencies of indicated packages and/or editable project locations.</p> <p>You may refer to the <code>dependence freeze</code> CLI reference and/or <code>dependence.freeze</code> API reference for details concerning this command/module, related options, and more complex use case examples.</p> <p>We'll use this project, <code>dependence</code>, as a simple example. To start with, let's see what the currently installed dependencies for this package look like at the time of writing:</p> <pre><code>$ dependence freeze .\npackaging==24.1\npip==24.3.0\nsetuptools==75.1.0\ntomli==2.1.0\ntomli_w==1.0.0\n</code></pre> <p>...now let's save this output for later comparison purposes:</p> <pre><code>dependence freeze . &gt; requirements_before.txt\n</code></pre> <p>Now, we'll upgrade our dependencies and see what they look like after:</p> <pre><code>$ pip install -q --upgrade --upgrade-strategy eager . &amp;&amp; dependence freeze .\npackaging==24.2\npip==24.3.1\nsetuptools==75.3.0\ntomli==2.2.1\ntomli_w==1.0.0\n</code></pre> <p>...next let's dump them to a file and compare them with our previous dependencies:</p> <pre><code>$ dependence freeze . &gt; dependence_after.txt\n$ diff dependence_before.txt dependence_after.txt\n1,5c1,5\n&lt; packaging==24.1\n&lt; pip==24.3.0\n&lt; setuptools==75.1.0\n&lt; tomli==2.1.0\n&lt; tomli_w==1.0.0\n---\n&gt; packaging==24.2\n&gt; pip==24.3.1\n&gt; setuptools==75.3.0\n&gt; tomli==2.2.1\n&gt; tomli_w==1.0.1\n</code></pre> <p>As you can see above, all of our dependencies have been upgraded.</p>"},{"location":"#updating-requirement-specifiers","title":"Updating Requirement Specifiers","text":"<p>To start with, let's take a look at our pyproject.toml file:</p> <pre><code>[project]\nname = \"dependence\"\nversion = \"1.0.0\"\ndependencies = [\n    \"packaging&gt;23\",\n    \"pip\",\n    \"setuptools&gt;63\",\n    \"tomli-w~=1.0\",\n    \"tomli~=2.1\",\n]\n</code></pre> <p>Now that we've upgraded our dependencies, we want to update our pyproject.toml file to align with our upgraded dependencies. This is desirable to ensure that <code>dependence</code> isn't installed alongside a version of one of its dependencies preceding functionality utilized by <code>dependence</code>.</p> <pre><code>dependence update pyproject.toml\n</code></pre> <p>Afterwards, our pyproject.toml file looks like this:</p> <pre><code>[project]\nname = \"dependence\"\nversion = \"1.0.0\"\ndependencies = [\n    \"packaging&gt;23\",\n    \"pip\",\n    \"setuptools&gt;63\",\n    \"tomli-w~=1.0\",\n    \"tomli~=2.2\",\n]\n</code></pre> <p>Here's the diff:</p> <pre><code>$ diff pyproject_before.toml pyproject_after.toml\n9c9\n&lt;     \"tomli~=2.1\",\n---\n&gt;     \"tomli~=2.2\",\n</code></pre> <p>As you can see, only the version specifier for tomli changed. We know that every dependency was upgraded, so why was only the <code>tomli</code> version specifier updated? By design. Here are the rules <code>dependence update</code> adheres to:</p> <ul> <li>We only update requirements versions when they have inclusive specifiers.     For example, <code>~=</code>, <code>&gt;=</code>, and <code>&lt;=</code> are inclusive, whereas <code>!=</code>, <code>&gt;</code>, and     <code>&lt;</code> are exclusive. For this reason, nothing changed for     \"packaging\" and \"setuptools\" in our above example.</li> <li>We always retain the existing level of specificity. If your version     specifier is <code>~=1.2</code>, and the new version is <code>1.5.6</code>, we're going to     update your specifier to <code>~=1.5</code>. If your requirement has a minor version     level of specificity, and only a patch version upgrade is performed,     nothing will change in your project dependency specifier. This is why     you do not see any change in our above pyproject.toml file for the     <code>tomli-w</code> dependency\u2014both new and old share the same minor version.</li> <li>If your requirement is unversioned, we don't touch it, of course. This is     why you didn't see any change for \"pip\".</li> </ul> <p>You may refer to the <code>dependence update</code> CLI reference and/or <code>dependence.update</code> API reference for details concerning this command/module, related options, and more complex use cases/examples.</p>"},{"location":"cli/","title":"Command Line Interface","text":"<pre><code>$ dependence -h\nUsage:\n  dependence &lt;command&gt; [options]\n\nCommands:\n  update                      Update requirement versions in the specified\n                              files to align with currently installed versions\n                              of each distribution\n  freeze                      Print dependencies inferred from an installed\n                              distribution or project, in a similar format\n                              to the output of `pip freeze`.\n  upgrade                     Upgrade all dependencies and align project\n                              requirement specifiers to match.\n</code></pre>"},{"location":"cli/#dependence-update","title":"dependence update","text":"<p>This command will update version specifiers for all package requirements in your setup.cfg, pyproject.toml, tox.ini, or requirements.txt files to match currently installed versions of each distribution (matching the existing granularity, and only for inclusive specifiers\u2014so where the comparator is \"~=\", \"==\", \"&gt;=\", or \"&lt;=\", but not where the comparator is \"&gt;\", \"&lt;\", or \"!=\").</p> <pre><code>$ dependence update -h\nusage: dependence update [-h] [-i IGNORE] [-aen ALL_EXTRA_NAME]\n                         [--include-pointer INCLUDE_POINTER]\n                         [--exclude-pointer EXCLUDE_POINTER]\n                         path [path ...]\n\nUpdate requirement versions in the specified files to align with currently\ninstalled versions of each distribution.\n\npositional arguments:\n  path                  One or more local paths to a *.toml, setup.cfg,\n                        and/or requirements.txt file\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -i IGNORE, --ignore IGNORE\n                        A comma-separated list of distributions to ignore\n                        (leave any requirements pertaining to the package\n                        as-is)\n  -aen ALL_EXTRA_NAME, --all-extra-name ALL_EXTRA_NAME\n                        If provided, an extra which consolidates the\n                        requirements for all other extras will be\n                        added/updated to pyproject.toml or setup.cfg (this\n                        argument is ignored for requirements.txt files and\n                        other TOML files)\n  --include-pointer INCLUDE_POINTER\n                        One or more JSON pointers of elements to *include*\n                        (applies to TOML files only)\n  --exclude-pointer EXCLUDE_POINTER\n                        One or more JSON pointers of elements to *exclude*\n                        (applies to TOML files only)\n</code></pre> <p>Example:</p> <pre><code>dependence update -aen all setup.cfg pyproject.toml tox.ini\n</code></pre>"},{"location":"cli/#dependence-freeze","title":"dependence freeze","text":"<pre><code>$ dependence freeze -h\nusage: dependence freeze [-h] [-e EXCLUDE] [-er EXCLUDE_RECURSIVE]\n                         [-nv NO_VERSION] [-do] [--reverse] [-d DEPTH]\n                         [--include-pointer INCLUDE_POINTER]\n                         [--exclude-pointer EXCLUDE_POINTER]\n                         requirement [requirement ...]\n\nThis command prints dependencies inferred from an installed distribution\nor project, in a similar format to the output of `pip freeze`, except that\nall generated requirements are specified in the format \"distribution-\nname==0.0.0\" (including for editable installations). Using this command\ninstead of `pip freeze` to generate requirement files ensures that you\ndon't bloat your requirements files with superfluous distributions.\n\npositional arguments:\n  requirement           One or more requirement specifiers (for example:\n                        \"requirement-name\", \"requirement-\n                        name[extra-a,extra-b]\", \".[extra-a, extra-b]\" or\n                        \"../other-editable-package-directory[extra-a,\n                        extra-b]) and/or paths to a setup.py, setup.cfg,\n                        pyproject.toml, tox.ini or requirements.txt file\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -e EXCLUDE, --exclude EXCLUDE\n                        A distribution (or comma-separated list of\n                        distributions) to exclude from the output\n  -er EXCLUDE_RECURSIVE, --exclude-recursive EXCLUDE_RECURSIVE\n                        A distribution (or comma-separated list of\n                        distributions) to exclude from the output. Unlike\n                        -e / --exclude, this argument also precludes\n                        recursive requirement discovery for the specified\n                        packages, thereby excluding all of the excluded\n                        package's requirements which are not required by\n                        another (non-excluded) distribution.\n  -nv NO_VERSION, --no-version NO_VERSION\n                        Don't include versions (only output distribution\n                        names) for packages matching this/these glob\n                        pattern(s) (note: the value must be single-quoted\n                        if it contains wildcards)\n  -do, --dependency-order\n                        Sort requirements so that dependents precede\n                        dependencies\n  --reverse             Print requirements in reverse order\n  -d DEPTH, --depth DEPTH\n                        Depth of recursive requirement discovery\n  --include-pointer INCLUDE_POINTER\n                        One or more JSON pointers of elements to *include*\n                        (applies to TOML files only)\n  --exclude-pointer EXCLUDE_POINTER\n                        One or more JSON pointers of elements to *exclude*\n                        (applies to TOML files only)\n</code></pre>"},{"location":"cli/#dependence-upgrade","title":"dependence upgrade","text":"<pre><code>$ dependence upgrade -h\nusage: dependence upgrade [-h] [-iu IGNORE_UPDATE] [-aen ALL_EXTRA_NAME]\n                          [--include-pointer INCLUDE_POINTER]\n                          [--exclude-pointer EXCLUDE_POINTER] [-e EXCLUDE]\n                          [-er EXCLUDE_RECURSIVE] [-d DEPTH]\n                          requirement [requirement ...]\n\nUpgrade all dependencies for specified packages/projects, then upgrade\nversion specifiers in the project files to align with newly installed\nversions of each distribution.\n\npositional arguments:\n  requirement           One or more requirement specifiers (for example:\n                        \"requirement-name\", \"requirement-\n                        name[extra-a,extra-b]\", \".[extra-a, extra-b]\" or\n                        \"../other-editable-package-directory[extra-a,\n                        extra-b]) and/or paths to a setup.py, setup.cfg,\n                        pyproject.toml, tox.ini or requirements.txt file\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -iu IGNORE_UPDATE, --ignore-update IGNORE_UPDATE\n                        A comma-separated list of distributions to ignore\n                        (leave any requirements pertaining to the package\n                        as-is) when updating project files\n  -aen ALL_EXTRA_NAME, --all-extra-name ALL_EXTRA_NAME\n                        If provided, an extra which consolidates the\n                        requirements for all other extras will be\n                        added/updated to pyproject.toml or setup.cfg (this\n                        argument is ignored for requirements.txt files and\n                        other TOML files)\n  --include-pointer INCLUDE_POINTER\n                        One or more JSON pointers of elements to *include*\n                        (applies to TOML files only)\n  --exclude-pointer EXCLUDE_POINTER\n                        One or more JSON pointers of elements to *exclude*\n                        (applies to TOML files only)\n  -e EXCLUDE, --exclude EXCLUDE\n                        A distribution (or comma-separated list of\n                        distributions) to exclude when performing upgrades\n  -er EXCLUDE_RECURSIVE, --exclude-recursive EXCLUDE_RECURSIVE\n                        A distribution (or comma-separated list of\n                        distributions) to exclude when performing upgrades.\n                        Unlike -e / --exclude, this argument also precludes\n                        recursive requirement discovery for the specified\n                        packages, thereby excluding all of the excluded\n                        package's requirements which are not required by\n                        another (non-excluded) distribution from the\n                        upgrade.\n  -d DEPTH, --depth DEPTH\n                        Depth of recursive requirement discovery\n</code></pre>"},{"location":"contributing/","title":"Contributing to dependence","text":""},{"location":"contributing/#for-enorganic-contributors-and-code-owners","title":"For Enorganic Contributors and Code Owners","text":"<ol> <li> <p>Clone and Install</p> <p>To install this project for development of this library, clone this repository (replacing \"~/Code\", below, with the directory under which you want your project to reside), then run <code>make</code>:</p> <pre><code>cd ~/Code &amp;&amp; \\\ngit clone\\\nhttps://github.com/enorganic/dependence.git dependence &amp;&amp; \\\ncd dependence &amp;&amp; \\\nmake\n</code></pre> </li> <li> <p>Create a new branch for your changes (replacing \"descriptive-branch-name\"     with a descriptive branch name, and replacing feature with bugfix     if the branch addresses a bug):</p> <pre><code>git branch feature/descriptive-branch-name\n</code></pre> </li> <li> <p>Make some changes.</p> </li> <li> <p>Format and lint your code:</p> <pre><code>make format\n</code></pre> </li> <li> <p>Test your changes:</p> <pre><code>make test\n</code></pre> </li> <li> <p>Push your changes and create a pull request.</p> </li> </ol>"},{"location":"contributing/#for-everyone-else","title":"For Everyone Else","text":"<p>If you are not a contributor on this project, you can still create pull requests, however you will need to fork this project, push changes to your fork, and create a pull request from your forked repository.</p>"},{"location":"api/freeze/","title":"freeze","text":""},{"location":"api/freeze/#dependence.freeze","title":"dependence.freeze","text":""},{"location":"api/freeze/#dependence.freeze.get_frozen_requirements","title":"get_frozen_requirements","text":"<pre><code>get_frozen_requirements(\n    requirements: collections.abc.Iterable[\n        str | pathlib.Path\n    ] = (),\n    *,\n    exclude: collections.abc.Iterable[str] = (),\n    exclude_recursive: collections.abc.Iterable[str] = (),\n    keep_version_specifier: collections.abc.Iterable[\n        str\n    ] = (),\n    no_version: collections.abc.Iterable[str] = (),\n    dependency_order: bool = False,\n    reverse: bool = False,\n    depth: int | None = None,\n    include_pointers: tuple[str, ...] = (),\n    exclude_pointers: tuple[str, ...] = ()\n) -&gt; tuple[str, ...]\n</code></pre> <p>Get the (frozen) requirements for one or more specified distributions or configuration files.</p> <p>Parameters:</p> <ul> <li> <code>requirements</code>               (<code>collections.abc.Iterable[str | pathlib.Path]</code>, default:                   <code>()</code> )           \u2013            <p>One or more requirement specifiers (for example: \"requirement-name[extra-a,extra-b]\" or \".[extra-a, extra-b]) and/or paths to a setup.cfg, pyproject.toml, tox.ini or requirements.txt file</p> </li> <li> <code>exclude</code>               (<code>collections.abc.Iterable[str]</code>, default:                   <code>()</code> )           \u2013            <p>One or more distributions to exclude/ignore</p> </li> <li> <code>exclude_recursive</code>               (<code>collections.abc.Iterable[str]</code>, default:                   <code>()</code> )           \u2013            <p>One or more distributions to exclude/ignore. Note: Excluding a distribution here excludes all requirements which would be identified through recursion.</p> </li> <li> <code>keep_version_specifier</code>               (<code>collections.abc.Iterable[str]</code>, default:                   <code>()</code> )           \u2013            <p>Keep the original (non-frozen) version specifier for package names matching any of these patterns. This supercedes <code>no_version</code>, if both sets of patterns match a package name.</p> </li> <li> <code>no_version</code>               (<code>collections.abc.Iterable[str]</code>, default:                   <code>()</code> )           \u2013            <p>Exclude version numbers from the output (only return distribution names). This is superceded by <code>keep_version_specifier</code>, if both sets of patterns match a package name.</p> </li> <li> <code>dependency_order</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Sort requirements so that dependents precede dependencies</p> </li> <li> <code>depth</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Depth of recursive requirement discovery</p> </li> <li> <code>include_pointers</code>               (<code>tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>A tuple of JSON pointers indicating elements to include (defaults to all elements). Only applies to TOML files.</p> </li> <li> <code>exclude_pointers</code>               (<code>tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>A tuple of JSON pointers indicating elements to exclude (defaults to no exclusions). Only applies to TOML files.</p> </li> </ul> Source code in <code>src/dependence/freeze.py</code> <pre><code>def get_frozen_requirements(  # noqa: C901\n    requirements: Iterable[str | Path] = (),\n    *,\n    exclude: Iterable[str] = (),\n    exclude_recursive: Iterable[str] = (),\n    keep_version_specifier: Iterable[str] = (),\n    no_version: Iterable[str] = (),\n    dependency_order: bool = False,\n    reverse: bool = False,\n    depth: int | None = None,\n    include_pointers: tuple[str, ...] = (),\n    exclude_pointers: tuple[str, ...] = (),\n) -&gt; tuple[str, ...]:\n    \"\"\"\n    Get the (frozen) requirements for one or more specified distributions or\n    configuration files.\n\n    Parameters:\n        requirements: One or more requirement specifiers (for example:\n            \"requirement-name[extra-a,extra-b]\" or \".[extra-a, extra-b]) and/or\n            paths to a setup.cfg, pyproject.toml, tox.ini or requirements.txt\n            file\n        exclude: One or more distributions to exclude/ignore\n        exclude_recursive: One or more distributions to exclude/ignore.\n            Note: Excluding a distribution here excludes all requirements which\n            would be identified through recursion.\n        keep_version_specifier: Keep the original (non-frozen) version\n            specifier for package names matching any of these patterns. This\n            supercedes `no_version`, if both sets of patterns match a package\n            name.\n        no_version: Exclude version numbers from the output\n            (only return distribution names). This is superceded by\n            `keep_version_specifier`, if both sets of patterns match a package\n            name.\n        dependency_order: Sort requirements so that dependents\n            precede dependencies\n        depth: Depth of recursive requirement discovery\n        include_pointers: A tuple of JSON pointers indicating elements to\n            include (defaults to all elements). Only applies to TOML files.\n        exclude_pointers: A tuple of JSON pointers indicating elements to\n            exclude (defaults to no exclusions). Only applies to TOML files.\n    \"\"\"\n    if isinstance(requirements, (str, Path)):\n        requirements = {str(requirements)}\n    else:\n        requirements = set(map(str, requirements))\n    if isinstance(no_version, str):\n        no_version = (no_version,)\n    elif not isinstance(no_version, tuple):\n        no_version = tuple(no_version)\n    if isinstance(keep_version_specifier, str):\n        keep_version_specifier = (keep_version_specifier,)\n    elif not isinstance(keep_version_specifier, tuple):\n        keep_version_specifier = tuple(keep_version_specifier)\n    # Separate requirement strings from requirement files\n    configuration_files: dict[str, dict[str, tuple[str, ...]]] = {}\n    requirement_strings: MutableSet[str] = set()\n    requirement: str | Path\n    for requirement in requirements:\n        if TYPE_CHECKING:\n            assert isinstance(requirement, str)\n        requirement_configuration_files: set[str] = set(\n            iter_configuration_files(requirement)\n        )\n        if requirement_configuration_files:\n            is_directory: bool = os.path.isdir(requirement)\n            for (\n                requirement_configuration_file\n            ) in requirement_configuration_files:\n                configuration_files[requirement_configuration_file] = (\n                    {\"include_pointers\": (\"/project\",)}\n                    if (\n                        is_directory\n                        and os.path.basename(\n                            requirement_configuration_file\n                        ).lower()\n                        == \"pyproject.toml\"\n                    )\n                    else {\n                        \"include_pointers\": include_pointers,\n                        \"exclude_pointers\": exclude_pointers,\n                    }\n                )\n        else:\n            if requirement.startswith(\"setup.py\"):\n                raise ValueError(requirement)\n            requirement_strings.add(requirement)\n    configuration_file: str\n    kwargs: dict[str, tuple[str, ...]]\n    frozen_requirements: Iterable[str] = iter_distinct(\n        chain(\n            requirement_strings,\n            *(\n                iter_configuration_file_requirement_strings(\n                    configuration_file, **kwargs\n                )\n                for configuration_file, kwargs in configuration_files.items()\n            ),\n        )\n    )\n    frozen_requirements = tuple(frozen_requirements)\n    if depth is not None:\n        depth -= 1\n    if (depth is None) or depth &gt;= 0:\n        frozen_requirements = _iter_frozen_requirements(\n            frozen_requirements,\n            exclude=set(\n                chain(\n                    # Exclude requirement strings which are *not*\n                    # distribution names (such as editable package paths),\n                    # as in these cases we are typically looking for this\n                    # package's dependencies\n                    (\n                        set(\n                            map(\n                                get_requirement_string_distribution_name,\n                                requirement_strings,\n                            )\n                        )\n                        - set(map(normalize_name, requirement_strings))\n                    ),\n                    map(normalize_name, exclude),\n                )\n            ),\n            exclude_recursive=set(map(normalize_name, exclude_recursive)),\n            no_version=no_version,\n            keep_version_specifier=keep_version_specifier,\n            depth=depth,\n        )\n    if dependency_order:\n        frozen_requirements = tuple(\n            _iter_sort_dependents_last(frozen_requirements)\n        )\n        if not reverse:\n            frozen_requirements = tuple(reversed(frozen_requirements))\n    else:\n        name: str\n        frozen_requirements = tuple(\n            sorted(\n                frozen_requirements,\n                key=lambda name: name.lower(),\n                reverse=reverse,\n            )\n        )\n    return frozen_requirements\n</code></pre>"},{"location":"api/freeze/#dependence.freeze.freeze","title":"freeze","text":"<pre><code>freeze(\n    requirements: collections.abc.Iterable[\n        str | pathlib.Path\n    ] = (),\n    *,\n    exclude: collections.abc.Iterable[str] = (),\n    exclude_recursive: collections.abc.Iterable[str] = (),\n    no_version: collections.abc.Iterable[str] = (),\n    dependency_order: bool = False,\n    reverse: bool = False,\n    depth: int | None = None,\n    include_pointers: tuple[str, ...] = (),\n    exclude_pointers: tuple[str, ...] = (),\n    keep_version_specifier: collections.abc.Iterable[\n        str\n    ] = ()\n) -&gt; None\n</code></pre> <p>Print the (frozen) requirements for one or more specified requirements or configuration files.</p> <p>Parameters:</p> <ul> <li> <code>requirements</code>               (<code>collections.abc.Iterable[str | pathlib.Path]</code>, default:                   <code>()</code> )           \u2013            <p>One or more requirement specifiers (for example: \"requirement-name[extra-a,extra-b]\" or \".[extra-a, extra-b]) and/or paths to a setup.py, setup.cfg, pyproject.toml, tox.ini or requirements.txt file</p> </li> <li> <code>exclude</code>               (<code>collections.abc.Iterable[str]</code>, default:                   <code>()</code> )           \u2013            <p>One or more distributions to exclude.</p> </li> <li> <code>exclude_recursive</code>               (<code>collections.abc.Iterable[str]</code>, default:                   <code>()</code> )           \u2013            <p>One or more distributions to exclude. Recursive dependency discovery is also halted for these distributions, unlike those passed to <code>exclude</code>.</p> </li> <li> <code>no_version</code>               (<code>collections.abc.Iterable[str]</code>, default:                   <code>()</code> )           \u2013            <p>Exclude version numbers from the output (only print distribution names) for package names matching any of these patterns</p> </li> <li> <code>dependency_order</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Sort requirements so that dependents precede dependencies</p> </li> <li> <code>depth</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Depth of recursive requirement discovery</p> </li> <li> <code>include_pointers</code>               (<code>tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>If this not empty, only these TOML tables will inspected (for pyproject.toml files)</p> </li> <li> <code>exclude_pointers</code>               (<code>tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>If not empty, these TOML tables will not be inspected (for pyproject.toml files)</p> </li> </ul> Source code in <code>src/dependence/freeze.py</code> <pre><code>def freeze(\n    requirements: Iterable[str | Path] = (),\n    *,\n    exclude: Iterable[str] = (),\n    exclude_recursive: Iterable[str] = (),\n    no_version: Iterable[str] = (),\n    dependency_order: bool = False,\n    reverse: bool = False,\n    depth: int | None = None,\n    include_pointers: tuple[str, ...] = (),\n    exclude_pointers: tuple[str, ...] = (),\n    keep_version_specifier: Iterable[str] = (),\n) -&gt; None:\n    \"\"\"\n    Print the (frozen) requirements for one or more specified requirements or\n    configuration files.\n\n    Parameters:\n        requirements: One or more requirement specifiers (for example:\n            \"requirement-name[extra-a,extra-b]\" or \".[extra-a, extra-b]) and/or\n            paths to a setup.py, setup.cfg, pyproject.toml, tox.ini or\n            requirements.txt file\n        exclude: One or more distributions to exclude.\n        exclude_recursive: One or more distributions to exclude. Recursive\n            dependency discovery is also halted for these distributions,\n            unlike those passed to `exclude`.\n        no_version: Exclude version numbers from the output\n            (only print distribution names) for package names matching any of\n            these patterns\n        dependency_order: Sort requirements so that dependents\n            precede dependencies\n        depth: Depth of recursive requirement discovery\n        include_pointers: If this not empty, *only* these TOML tables will\n            inspected (for pyproject.toml files)\n        exclude_pointers: If not empty, these TOML tables will *not* be\n            inspected (for pyproject.toml files)\n    \"\"\"\n    print(  # noqa: T201\n        \"\\n\".join(\n            get_frozen_requirements(\n                requirements=requirements,\n                exclude=exclude,\n                exclude_recursive=exclude_recursive,\n                no_version=no_version,\n                dependency_order=dependency_order,\n                reverse=reverse,\n                depth=depth,\n                include_pointers=include_pointers,\n                exclude_pointers=exclude_pointers,\n                keep_version_specifier=keep_version_specifier,\n            )\n        )\n    )\n</code></pre>"},{"location":"api/update/","title":"update","text":""},{"location":"api/update/#dependence.update","title":"dependence.update","text":""},{"location":"api/update/#dependence.update.update","title":"update","text":"<pre><code>update(\n    paths: collections.abc.Iterable[str | pathlib.Path],\n    *,\n    ignore: collections.abc.Iterable[str] = (),\n    all_extra_name: str = \"\",\n    include_pointers: tuple[str, ...] = (),\n    exclude_pointers: tuple[str, ...] = ()\n) -&gt; None\n</code></pre> <p>Update requirement versions in the specified files.</p> <p>Parameters:</p> <ul> <li> <code>paths</code>               (<code>collections.abc.Iterable[str | pathlib.Path]</code>)           \u2013            <p>One or more local paths to a pyproject.toml, setup.cfg, and/or requirements.txt files</p> </li> <li> <code>ignore</code>               (<code>collections.abc.Iterable[str]</code>, default:                   <code>()</code> )           \u2013            <p>One or more project/package names or patterns to ignore (leave as-is) when updating dependency requirement specifiers.</p> </li> <li> <code>all_extra_name</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>If provided, an extra which consolidates the requirements for all other extras will be added/updated to pyproject.toml or setup.cfg (this argument is ignored for requirements.txt files)</p> </li> <li> <code>include_pointers</code>               (<code>tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>A tuple of JSON pointers indicating elements to include (defaults to all elements). This applies only to TOML files (including pyproject.toml), and is ignored for all other file types.</p> </li> <li> <code>exclude_pointers</code>               (<code>tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>A tuple of JSON pointers indicating elements to exclude (defaults to no exclusions). This applies only to TOML files (including pyproject.toml), and is ignored for all other file types.</p> </li> </ul> Source code in <code>src/dependence/update.py</code> <pre><code>def update(\n    paths: Iterable[str | Path],\n    *,\n    ignore: Iterable[str] = (),\n    all_extra_name: str = \"\",\n    include_pointers: tuple[str, ...] = (),\n    exclude_pointers: tuple[str, ...] = (),\n) -&gt; None:\n    \"\"\"\n    Update requirement versions in the specified files.\n\n    Parameters:\n        paths: One or more local paths to a pyproject.toml,\n            setup.cfg, and/or requirements.txt files\n        ignore: One or more project/package names or patterns to ignore (leave\n            as-is) when updating dependency requirement specifiers.\n        all_extra_name: If provided, an extra which consolidates\n            the requirements for all other extras will be added/updated to\n            pyproject.toml or setup.cfg (this argument is ignored for\n            requirements.txt files)\n        include_pointers: A tuple of JSON pointers indicating elements to\n            include (defaults to all elements). This applies only to TOML\n            files (including pyproject.toml), and is ignored for all other\n            file types.\n        exclude_pointers: A tuple of JSON pointers indicating elements to\n            exclude (defaults to no exclusions). This applies only to TOML\n            files (including pyproject.toml), and is ignored for all other\n            file types.\n    \"\"\"\n    if isinstance(paths, (str, Path)):\n        paths = (paths,)\n\n    def update_(path: str | Path) -&gt; None:\n        _update(\n            path,\n            ignore=ignore,\n            all_extra_name=all_extra_name,\n            include_pointers=include_pointers,\n            exclude_pointers=exclude_pointers,\n        )\n\n    deque(map(update_, paths), maxlen=0)\n</code></pre>"},{"location":"api/upgrade/","title":"upgrade","text":""},{"location":"api/upgrade/#dependence.upgrade","title":"dependence.upgrade","text":""},{"location":"api/upgrade/#dependence.upgrade.upgrade","title":"upgrade","text":"<pre><code>upgrade(\n    requirements: collections.abc.Iterable[str],\n    *,\n    ignore_update: collections.abc.Iterable[str] = (),\n    all_extra_name: str = \"\",\n    include_pointers: tuple[str, ...] = (),\n    exclude_pointers: tuple[str, ...] = (),\n    exclude: collections.abc.Iterable[str] = (),\n    exclude_recursive: collections.abc.Iterable[str] = (),\n    depth: int | None = None,\n    echo: bool = False\n) -&gt; None\n</code></pre> <p>This function obtains a list of dependencies for the specified <code>requirements</code> using <code>dependence.update.get_frozen_requirements()</code>, upgrades all of these dependencies in the current environment, then updates version specifiers for all requirements/dependencies in any or the <code>requirements</code> which are project config files to align with the newly installed package versions (using <code>dependence.update.update()</code>).</p> <p>Parameters:</p> <ul> <li> <code>requirements</code>               (<code>collections.abc.Iterable[str]</code>)           \u2013            <p>One or more requirement specifiers (for example: \"requirement-name[extra-a,extra-b]\" or \".[extra-a, extra-b]) and/or paths to a setup.py, setup.cfg, pyproject.toml, tox.ini or requirements.txt file.</p> </li> <li> <code>ignore_update</code>               (<code>collections.abc.Iterable[str]</code>, default:                   <code>()</code> )           \u2013            <p>One or more project names to ignore (leave as-is) when updating a dependency's requirement specifier in the provided pyproject.toml/setup.cfg/requirements.txt/tox.ini file(s). Note that this does not prevent the package from being upgraded\u2014for that you need to pass the package name in <code>exclude</code> or <code>exclude_recursive</code>.</p> </li> <li> <code>all_extra_name</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>If provided, an extra which consolidates the requirements for all other extras will be added/updated to pyproject.toml or setup.cfg (this argument is ignored for requirements.txt and tox.ini files).</p> </li> <li> <code>include_pointers</code>               (<code>tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>A tuple of JSON pointers indicating elements to include (defaults to all elements). This applies only to TOML files (including pyproject.toml), and is ignored for all other file types.</p> </li> <li> <code>exclude_pointers</code>               (<code>tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>A tuple of JSON pointers indicating elements to exclude (defaults to no exclusions). This applies only to TOML files (including pyproject.toml), and is ignored for all other file types.</p> </li> <li> <code>exclude</code>               (<code>collections.abc.Iterable[str]</code>, default:                   <code>()</code> )           \u2013            <p>One or more distributions to exclude when upgrading packages.</p> </li> <li> <code>exclude_recursive</code>               (<code>collections.abc.Iterable[str]</code>, default:                   <code>()</code> )           \u2013            <p>One or more distributions to exclude when upgrading packages. Recursive dependency discovery is also halted for these distributions, unlike those passed to <code>exclude</code>.</p> </li> <li> <code>depth</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The maximum recursion depth to traverse when discovering dependencies. If <code>None</code> (the default), all dependencies are discovered.</p> </li> </ul> Source code in <code>src/dependence/upgrade.py</code> <pre><code>def upgrade(\n    requirements: Iterable[str],\n    *,\n    ignore_update: Iterable[str] = (),\n    all_extra_name: str = \"\",\n    include_pointers: tuple[str, ...] = (),\n    exclude_pointers: tuple[str, ...] = (),\n    exclude: Iterable[str] = (),\n    exclude_recursive: Iterable[str] = (),\n    depth: int | None = None,\n    echo: bool = False,\n) -&gt; None:\n    \"\"\"\n    This function obtains a list of dependencies for the specified\n    `requirements` using `dependence.update.get_frozen_requirements()`,\n    upgrades all of these dependencies in the current environment,\n    then updates version specifiers for all requirements/dependencies\n    in any or the `requirements` which are project config files\n    to align with the newly installed package versions (using\n    `dependence.update.update()`).\n\n    Parameters:\n        requirements: One or more requirement specifiers (for example:\n            \"requirement-name[extra-a,extra-b]\" or \".[extra-a, extra-b]) and/or\n            paths to a setup.py, setup.cfg, pyproject.toml, tox.ini or\n            requirements.txt file.\n        ignore_update: One or more project names to ignore (leave as-is)\n            when updating a dependency's requirement specifier in the\n            provided pyproject.toml/setup.cfg/requirements.txt/tox.ini\n            file(s). Note that this does not prevent the package from being\n            upgraded\u2014for that you need to pass the package name in\n            `exclude` or `exclude_recursive`.\n        all_extra_name: If provided, an extra which consolidates\n            the requirements for all other extras will be added/updated to\n            pyproject.toml or setup.cfg (this argument is ignored for\n            requirements.txt and tox.ini files).\n        include_pointers: A tuple of JSON pointers indicating elements to\n            include (defaults to all elements). This applies only to TOML\n            files (including pyproject.toml), and is ignored for all other\n            file types.\n        exclude_pointers: A tuple of JSON pointers indicating elements to\n            exclude (defaults to no exclusions). This applies only to TOML\n            files (including pyproject.toml), and is ignored for all other\n            file types.\n        exclude: One or more distributions to exclude when upgrading packages.\n        exclude_recursive: One or more distributions to exclude when\n            upgrading packages. Recursive dependency discovery is also\n            halted for these distributions, unlike those passed to `exclude`.\n        depth: The maximum recursion depth to traverse when discovering\n            dependencies. If `None` (the default), all dependencies are\n            discovered.\n    \"\"\"\n    frozen_requirements: tuple[str, ...] = get_frozen_requirements(\n        requirements,\n        exclude=exclude,\n        exclude_recursive=exclude_recursive,\n        keep_version_specifier=\"*\",\n        no_version=\"*\",\n        depth=depth,\n        include_pointers=include_pointers,\n        exclude_pointers=exclude_pointers,\n    )\n    if frozen_requirements:\n        command: tuple[str, ...] = (\n            sys.executable,\n            \"-m\",\n            \"pip\",\n            \"install\",\n            \"--upgrade\",\n            *frozen_requirements,\n        )\n        check_output(command, echo=echo)\n    configuration_files: tuple[str, ...] = tuple(\n        chain(\n            *map(iter_configuration_files, requirements)  # type: ignore\n        )\n    )\n    if configuration_files:\n        update(\n            configuration_files,\n            ignore=ignore_update,\n            all_extra_name=all_extra_name,\n            include_pointers=include_pointers,\n            exclude_pointers=exclude_pointers,\n        )\n</code></pre>"}]}